### 이벤트 루프
    
```txt
js가 단일 스레드라는 건 웬만한 사람들은 다 아는 사실이다.
메인 스레드에서 모든 코드를 동기 처리해도 아무 불만 안 생기면 다행이지만...
```
![다운로드](https://user-images.githubusercontent.com/39308313/148635367-0b8f913d-422e-4126-a37f-73fa48413efb.jpg)

```txt
그래서 Event loop란 개념을 알아야 한다.
크게 다음과 같은 요소를 생각할 수 있다.
```

1. Call Stack
2. MacroTask Queue
3. MicroTask Queue
4. Animation Frame

- Call Stack

```txt
여러 메소드, 함수 등을 넣는 스택.
이벤트 루프는 콜스택 내에 있는 애들이 다 비워질 때까지 계속 돌린다.
```

- MacroTask Queue

```txt
이후로는 MacroTask 대신 Task Queue로 생략해서 부르겠다.
taskqueue에 들어가는 대표적 예시는 setTimeout이다.

 - 실행 원리

1. Call Stack에 setTimeout이 올라간다.

2. 내부 함수는 WepAPIs로 이동, setTimeout에 설정된 시간만큼 countdown을 한다.

3. Call Stack은 담겨있는 작업들을 처리.

4. 카운트 다운이 끝나면 setTimeout의 내부함수는 web API => task queue로 이동. 
※주의 : 카운트다운이 끝나면 task queue로 이동하는 거다. 카운트다운이 끝나고 바로 실행하는 게 아니다.

5. 내부함수는 Call Stack이 비워지면 그제야 Call Stack으로 넘겨진 다음 실행된다.

※ 구글엔 message queue vs task queue라는 주제가 있다.
둘이 다른 모양인데, 검색해서 알아보면 좋을 듯하다.

※ 겉보기에 큐처럼 행동하지만 실제 구조는 set이다.

※ Task Queue는 콜백 함수뿐 아니라 이벤트, 스크립트, HTML parse 등을 담는다.

※ setTimeout은 V8 소스 코드에 없다. 
브라우저에서 제공하는, js가 실행되는 런타임 환경에 있는 API이다.
```

<img src ="https://res.cloudinary.com/practicaldev/image/fetch/s--6NSYq-nO--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/yqoemb6f32lvovge8yrp.gif">

<img src="https://res.cloudinary.com/practicaldev/image/fetch/s--us8FF30N--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/6wxjxduh62fqt531e2rc.gif">

![image](https://user-images.githubusercontent.com/39308313/144360100-d6a69889-18f0-4e8e-a8c7-e835ed323bbb.png)

```javascript
function a() {
  console.log('a');
}

function b() {
  console.log('b');
}

function c() {
    setTimeout(b, 0);
    a();
    console.log('c');
}

c();
```

![image](https://user-images.githubusercontent.com/39308313/144221789-50c7f629-7fa5-4ec8-90b1-6ab53ed34199.png)

```txt
Call Stack: [c, a]
Message Queue : [ b ]
따라서 a -> c를 실행해서 콜스택을 비운 뒤에 메시지 큐에 있는 b가 콜스택으로 이동한 뒤 출력된다.

Q) 만약 아래처럼 코드를 짜면 어떻게 될까?
```

```javascript
function c() {
    setTimeout(b, 100);
    setTimeout(a, 0);
    console.log('c');
}
```

```txt
Call Stack : [c]
Message Queue : [a , b]
가 된다.
b는 100ms 뒤에 Call Stack으로 가는 게 아니라, 100ms 뒤에 Message Queue로 간다.
따라서 a가 먼저 메시지 큐에 들어갔기 때문에 a -> b 순으로 콜스택에 들어간다.
```

## 그래서 이거 왜 쓰는데?

![image](https://user-images.githubusercontent.com/39308313/144360746-b051a3da-561b-45f2-9efc-78e823293359.png)

```txt
setTimeout은 예시이다. setTimeout만 저렇게 돌아가는 게 아니다.
HTML에서 onClick()이벤트 처리 등도 이런 식으로 적용이 된다.
```

![image](https://user-images.githubusercontent.com/39308313/144361895-85407884-7049-4d0e-bb6d-c122ea7140db.png)

```txt
위 코드에서 그냥 forEach를 돌리면 각 index마다 console.log()를 동기적으로 돌린다. 

async로 돌릴 경우는 아래와 같이 된다.
```

![image](https://user-images.githubusercontent.com/39308313/144361671-f3a8b498-dc4b-4772-bb56-e68ed2823b09.png)

```txt
각 index마다 바로 콜스택을 비우는 게 아니라 큐에 집어넣는다.
```

### 왜 이렇게?

    콜스택이 비워지기 전엔 다른 작업을 못하니까.

```txt
몇 개 console.log 찍는 건 금방이니까 괜찮다. 
그런데 시간이 오래 걸리는 작업이면?
콜스택 비우는 데에도 시간이 오래 걸린다.

브라우저는 매 16.6ms마다 화면을 repaint한다(초당 60프레임).

그런데 Call Stack에 코드가 남아있으면 redering을 못한다

그동안에 텍스트 선택, 클릭 등 이벤트 작동도 다 막힌다.
왜? 스택에 있는 애들 처리하느라 바쁘니까.

이를 테면 마우스 스크롤 이벤트가 동기적으로 작동하면?
엄청 많은 함수들이 스택에 쌓일 것이고,
스크롤을 내리는 동안 다른 짓을 못한다.

따라서 필요에 따라 비동기로 작동시키는 것이다.

※기회가 된다면 타이머, 네트워크, 렌더링 주기마다 처리할 이벤트가 있다면 setTimeout 대신 rAF(requestAnimationFrame)을 써보자.
렌더링은 다음과 같은 단계를 거친다.
rAF => styling => Layout => Painting
(이건 깊게 들어가는 것 같으니 나중에 좀 더 공부가 필요할 때 해보자.)
```

```js
const Animation = () => {
	let x = 1;
	const box = document.querySelector("div");
	function moveBox() {
		box.style.transform = `translateX(${x}px)`;
		x += 5;
	}
	function callback() {
		moveBox();
		// requestAnimationFrame(callback);
		// setTimeout(callback, 1000 / 60);
	}
	callback();
	return (
		<>
			<div id="box" className={styles.box}></div>
		</>
	);
};
```

```txt
위와 같은 코드를 짰을 때, setTimeout과 requestAnimationFrame은 각각 초당 60프레임 간격으로 box를 오른쪽으로 움직인다.
```

![image](https://user-images.githubusercontent.com/39308313/148680983-45fd093a-f4f4-45ac-bd5f-ba9e774b9c06.png)

	우리는 setTimeout시 위와 같이 작동하기를 바란다.
        
![image](https://user-images.githubusercontent.com/39308313/148681027-be73ff40-0f15-45be-affa-033bfed1465c.png)

	하지만 정확하게 작동하지 않아서 루틴이 깨질 수도 있고, 작업 시간 때문에 렌더링이 늦춰질 수도 있다.
        
![image](https://user-images.githubusercontent.com/39308313/148681046-0475d612-a1a9-4d71-8d59-0918339c6544.png)

	requestAnimationFrame을 사용하면 위와 같이 작동하기 때문에 문제가 없다.
        
```txt
위의 코드를 각각 실행해보면 setTimeout은 실행 도중에 박스의 움직임이 뚝뚝 끊기는 순간이 존재하는 반면,
requestAnimationFrame은 부드럽게 잘 실행된다.
```

### Task Queue vs MicroTask Queue

![image](https://user-images.githubusercontent.com/39308313/148636153-0398ed21-e8c2-4e23-bc9f-d99224f9787d.png)

```txt
Task Queue는 Call Stack에 하나 넣고, Call Stack이 비워지길 기다리고, 다시 Call Stack에 하나 넣고, 기다린다.

Animation Callback Queue는 Call Stack에 순서대로 넣지만, 새로 추가되는 작업들은 다음 프레임에서 처리한다.

MicroTask Queue는 새로 들어오는 작업들도 포함해서 Queue가 다 비워질 때까지 계속 Call Stack에 넣는다.
```


![image](https://user-images.githubusercontent.com/39308313/148636323-d544b6fa-6490-4143-8d9c-381b534539c9.png)

```txt
콘솔 결과가 어떻게 뜰까?

※참고 : JavaScript 'promises' and the 'Mutation Observer API' both use the 'microtask queue' to run their callbacks
-MDN에서 발췌-

프로미스는 microTask Queue를 쓴다.

task queue에 클릭 메소드 2개가 들어갈 것이고, 첫 번째 클릭 이벤트 처리로 Listener 1 => MicroTask 1이 출력될 것이다.
그 다음으로 task queue에 남아있던 2번째 이벤트가 stack에 들어와서 처리될 것이다.
따라서 Listener 1 => MicroTask 1 => Listener 2 => MicroTask 2순으로 출력된다.
```

![image](https://user-images.githubusercontent.com/39308313/148649468-b58b5a7b-4420-4f78-acdf-dc9a80ffd54f.png)

```txt
이건 콘솔 결과가 어떻게 뜰까?

js script가 Call Stack에 깔려있기 때문에 웹에서 마우스 클릭했을 때와 완전히 다른 결과가 나온다.
첫 번째 클릭 이벤트를 처리해도 script가 Call Stack에 남아있기 때문에 두 번째 클릭 이벤트도 실행한다.
MicroTask Queue도 Call Stack이 비워질 때까진 기다려야 하기 때문에 MicroTask 1, MicroTask 2가 쌓여있는 상태다.
즉, 결과는 Listener 1 => Listener 2 => MicroTask 1 => MicroTask 2다.

아래와 같이 동작한다는 걸 확인하자.
```

<img src="https://res.cloudinary.com/practicaldev/image/fetch/s--05Fi8vBq--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/42eatw03fcha0e1qcrf0.gif">

```txt
wikidocs에서는 아래와 같이 event loop를 설명한다.

1. Task queue에서 가장 오래된 태스크를 실행
2. Microtask Checkpoint를 실행
3. 필요시, 렌더링 실행
	resize, scroll 등을 실행
	animation frame callbacks 실행 (requestAnimationFrame으로 추가된 callback을 말함)
	update intersection observation steps 실행
	화면 업데이트
	
Microtask Checkpoint 실행은 Microtask Queue에 담긴 microtask를 실행하는 것으로, 규칙은 아래와 같다.

1. “perfoming a microtask checkpoint” 변수가 false이면 계속한다.
2. “perfoming a microtask checkpoint”를 참으로 한다.
3. 이벤트 루프의 마이크로태스크 큐가 빌 때까지:
	마이크로태스크 큐의 가장 오래된 마이크로태스크를 실행한다.
	이 때, 실행 중인 마이크로태스크가 콜백을 실행하는 경우, Microtask Checkpoint가 실행되는데, 
	이 때에는 “perfoming a microtask checkpoint”가 이미 참이기 때문에, 이 반복문이 2중으로 실행되는 것을 방지한다.
```

### microTask Queue는 어디에 쓰나?

```txt
MDN에 들어가면 microtask queue를 쓸 일은 많지 않으며, 사용할 시에 주의가 필요하다고 한다.
권장하는 예시를 보자.
```

```js
// 1번 코드
customElement.prototype.getData = url => {
  if (this.cache[url]) {
    this.data = this.cache[url];
    this.dispatchEvent(new Event("load"));
  } else {
    fetch(url).then(result => result.arrayBuffer()).then(data => {
      this.cache[url] = data;
      this.data = data;
      this.dispatchEvent(new Event("load"));
    });
  }
};

// 2번 코드
customElement.prototype.getData = url => {
  if (this.cache[url]) {
    queueMicrotask(() => {
      this.data = this.cache[url];
      this.dispatchEvent(new Event("load"));
    });
  } else {
    fetch(url).then(result => result.arrayBuffer()).then(data => {
      this.cache[url] = data;
      this.data = data;
      this.dispatchEvent(new Event("load"));
    });
  }
};
```

```txt
1번 코드는 if문에서 작업이 task단에서 처리되고, else문에선 작업이 microtask단에서 처리된다.
if와 else에서 처리하는 단이 다르기 때문에 애로사항이 날 수 있다고 주의한다.

2번 코드는 다르다.

if문에서는 queueMicrotask를 씀으로서 작업을 microtask단에서 처리하고,
else문에서도 promise를 통해 작업을 microtask단에서 처리한다.

이를 통해 실행 순서를 일정하게 유지할 수 있도록 보장해준다고 한다.
```

[MDN 마이크로태스크](https://developer.mozilla.org/ko/docs/Web/API/HTML_DOM_API/Microtask_guide)  
[태스크와 마이크로태스크에 관하여](https://wikidocs.net/158522)
