# 이벤트 루프
    
```txt
js가 단일 스레드라는 건 웬만한 사람들은 다 아는 사실이다.
메인 스레드에서 모든 코드를 동기 처리해도 아무 불만 안 생기면 다행이지만...
```
![다운로드](https://user-images.githubusercontent.com/39308313/148635367-0b8f913d-422e-4126-a37f-73fa48413efb.jpg)

```txt
그래서 Event loop란 개념을 알아두면 좋다.

크게 다음과 같은 요소를 생각할 수 있다.
```

1. Call Stack
2. MacroTask
3. Animation Frame
4. MicroTask

## 【 Call Stack 】

```txt
여러 메소드, 함수 등을 넣는 스택.
이벤트 루프는 콜스택에 있는 애들이 다 비워질 때까지 계속 돌린다.
코드 실행 우선 순위는 Call stack -> microtask -> task라고 생각하면 편하다.
```

## 【 MacroTask 】

```txt
task로 생략해서 부르겠다.
task는 Call Stack에 바로 들어가서 실행되지 않는다.
taskQueue라는 중간 단계를 거쳐서 Call Stack에 전달된다.
가장 많이 볼 수 있는 대표 예시는 setTimeout()

 - 실행 원리

1. Call Stack에 setTimeout이 올라간다.

2. setTimeout()의 내부 함수는 WepAPIs로 전달.

3-1. wetAPIs는 setTimeout에서 설정한 시간만큼 countdown을 한다.

3-2. Call Stack은 담겨있는 작업들을 처리한다.

4. 카운트다운이 끝나면 setTimeout() 내부 함수(task)는 web APIs => task Queue로 전달.
※주의 : 이 때 카운트다운이 끝나면 바로 내부 함수를 실행하는 게 아니라 task queue로 전달할 뿐이다.

5. Call Stack이 비워지면 task queue에 있는 작업은 그제야 call stack으로 이동된다.

6. call Stack으로 옮겨진 함수는 실행한 뒤, 비워진다.


※ 겉보기에 큐처럼 행동하지만 실제 구조는 set이다.

※ Task Queue는 콜백 함수뿐 아니라 이벤트, 스크립트, HTML parse 등을 담는다.

※ setTimeout은 V8 소스 코드에 없다. 
브라우저에서 제공하는, js가 실행되는 런타임 환경에 있는 API이다.
```

<img src ="https://res.cloudinary.com/practicaldev/image/fetch/s--6NSYq-nO--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/yqoemb6f32lvovge8yrp.gif">

<img src="https://res.cloudinary.com/practicaldev/image/fetch/s--us8FF30N--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/6wxjxduh62fqt531e2rc.gif">


```txt
Q) 만약 아래처럼 코드를 짜면 출력 순서는 어떻게 될까?
```

```javascript
function a() {
  console.log('a');
}

function b() {
  console.log('b');
}

function c() {
    setTimeout(b, 0);
    a();
    console.log('c');
}

c();
```

```txt
아래는 어떻게 될까?
```

```javascript
function c() {
    setTimeout(b, 100);
    setTimeout(a, 0);
    console.log('c');
}
```

## 헷갈린다면 다시 살펴보자

![image](https://user-images.githubusercontent.com/39308313/144361895-85407884-7049-4d0e-bb6d-c122ea7140db.png)

```txt
forEach를 그냥 돌리면 각 index마다 console.log()를 동기적으로 돌린다. 
하지만 setTimeout을 써서 task에 넣어서 처리하면?
```

![image](https://user-images.githubusercontent.com/39308313/144361671-f3a8b498-dc4b-4772-bb56-e68ed2823b09.png)

### 왜 이렇게?

![image](https://user-images.githubusercontent.com/39308313/144360746-b051a3da-561b-45f2-9efc-78e823293359.png)

```txt
참고) onClick()이벤트 등등도 taskQueue에 들어가서 처리된다.
```

```txt
몇 개 console.log 찍는 건 금방이니까 괜찮다. 
그런데 시간이 오래 걸리는 작업이면?
콜스택 비우는 데에도 시간이 오래 걸린다.

브라우저는 매 16.6ms마다 화면을 repaint한다(초당 60프레임).

그런데 Call Stack에 코드가 남아있으면 redering을 못한다

처리중인 이벤트가 있으면 텍스트 선택, 클릭 등 다른 모든 이벤트가 다 막힌다.
스택에 있는 애들 처리하느라 바쁘니까.

만약 마우스 스크롤 등등의 모든 이벤트를 동기적으로 처리하다간 사용자가 속터질 것이다.

따라서 필요에 따라 비동기로 작동시키는 것이다.
```

## 【 Animation Frame 】

```txt
Animation Frame은 애니메이션 관련 작업을 할 게 아니면 크게 신경쓰지 않아도 될 부분이니 간단하게만 보자.

렌더링은 다음과 같은 단계를 거친다.
rAF => styling => Layout => Painting

CSS를 계산하기 전에 Animation Frame을 계산한다는 얘기다.
이 단계에서 처리하고 싶은 게 있으면 rAF(requestAnimationFrame) 메소드를 쓴다.
이 때, 렌더링 때마다 처리할 것이므로 작성한 함수는 콜백으로 계속 넘겨주도록 한다.
특정 주기동안만 하고 멈출 거면 Date() 등 조건을 써서 제한하자.
```

```js
const Animation = () => {
	let x = 1;
	const box = document.querySelector("div");
	function moveBox() {
		box.style.transform = `translateX(${x}px)`;
		x += 5;
	}
	function callback() {
		moveBox();
		// requestAnimationFrame(callback);
		// setTimeout(callback, 1000 / 60);
	}
	callback();
	return (
		<>
			<div id="box" className={styles.box}></div>
		</>
	);
};
```

```txt
위와 같은 코드를 짰을 때, setTimeout과 requestAnimationFrame은 각각 초당 60프레임 간격으로 box를 오른쪽으로 움직인다.
그러면 둘이 뭐가 다를까?
```

![image](https://user-images.githubusercontent.com/39308313/148680983-45fd093a-f4f4-45ac-bd5f-ba9e774b9c06.png)

	우린 보통 setTimeout이 위와 같이 작동할 거라고 기대한다.
        
![image](https://user-images.githubusercontent.com/39308313/148681027-be73ff40-0f15-45be-affa-033bfed1465c.png)

	하지만 정확하게 작동하지 않는다. 루틴이 깨질 수도 있고, 작업 처리에 필요한 시간 때문에 렌더링이 늦어질 수 있다.
        
![image](https://user-images.githubusercontent.com/39308313/148681046-0475d612-a1a9-4d71-8d59-0918339c6544.png)

```txt
requestAnimationFrame을 사용하면 위와 같이 렌더링마다 작동하기 때문에 깔끔하게 처리된다.
실제로 위의 코드를 각각 실행해보면 setTimeout은 도중에 박스의 움직임이 뚝뚝 끊기는 반면,
requestAnimationFrame은 부드럽게 움직인다.
```

## 【 MicroTask 】

```txt
JavaScript 'promises' and the 'Mutation Observer API' both use the 'microtask queue' to run their callbacks
-MDN에서 발췌-

microtask의 대표적 예시는 promise이다.

wikidocs에서는 아래와 같은 설명을 한다.

1. Task queue에서 가장 오래된 작업을 처리
2. Microtask Checkpoint 실행
3. 필요하다면 렌더링 실행
	resize, scroll 등을 실행
	animation frame callbacks 실행 (requestAnimationFrame을 사용한 콜백 함수)
	update intersection observation steps 실행
	화면 업데이트
	
Microtask Checkpoint 실행은 Microtask Queue에 담긴 microtask를 실행하는 것으로, 규칙은 아래와 같다.

1. “perfoming a microtask checkpoint” 변수가 false이면 계속한다.
2. “perfoming a microtask checkpoint”를 참으로 한다.
3. 이벤트 루프의 마이크로태스크 큐가 빌 때까지:
	마이크로태스크 큐의 가장 오래된 마이크로태스크를 실행한다.
	이 때, 실행 중인 마이크로태스크가 콜백을 실행하는 경우, Microtask Checkpoint가 실행되는데, 
	이 때에는 “perfoming a microtask checkpoint”가 이미 참이기 때문에, 이 반복문이 2중으로 실행되는 것을 방지한다.
	
아래와 같이 간단히 생각해보자.
```

![image](https://user-images.githubusercontent.com/39308313/148636153-0398ed21-e8c2-4e23-bc9f-d99224f9787d.png)

- Task Queue는 Call Stack에 하나 넣고, Call Stack이 비워지길 기다리고, 중간에 microtask나 렌더링이 있는지 확인한다.
(새로이 추가되는 task는 상황에 따라서 계속 실행할 수도 있고, 다른 작업에게 우선 순위를 양보할 수도 있다.)

- Animation Callback Queue는 Call Stack에 연속으로 넣지만, 새로이 추가되는 작업들은 다음 렌더링에서 처리한다.

- MicroTask Queue는 이벤트가 새로 생기더라도 Queue가 완전히 다 비워질 때까지 계속 Call Stack에 넣는다.

![image](https://user-images.githubusercontent.com/39308313/148636323-d544b6fa-6490-4143-8d9c-381b534539c9.png)

```txt
위와 같은 코드를 짰을 때, promise가 microtask임을 감안하면 어떻게 처리될까?

task queue에 클릭 메소드 2개가 들어갈 것이고, 첫 번째 클릭 이벤트 처리로 Listener 1 => MicroTask 1이 출력될 것이다.
그 다음으로 task queue에 남아있던 2번째 이벤트가 stack에 들어와서 처리될 것이다.
따라서 Listener 1 => MicroTask 1 => Listener 2 => MicroTask 2순으로 출력된다.
```

![image](https://user-images.githubusercontent.com/39308313/148649468-b58b5a7b-4420-4f78-acdf-dc9a80ffd54f.png)

```txt
이건 콘솔 결과가 어떻게 뜰까?

js script가 Call Stack에 깔려있기 때문에 웹에서 마우스 클릭했을 때와 완전히 다른 결과가 나온다.
첫 번째 클릭 이벤트를 처리해도 script가 Call Stack에 남아있기 때문에 두 번째 클릭 이벤트도 실행한다.
MicroTask Queue도 Call Stack이 비워질 때까진 기다려야 하기 때문에 MicroTask 1, MicroTask 2가 쌓여있는 상태다.
즉, 결과는 Listener 1 => Listener 2 => MicroTask 1 => MicroTask 2다.
```

# 그런데...

![6](https://user-images.githubusercontent.com/39308313/149320626-24faa018-4fc7-4260-9cf3-4223ea27c187.jpg)
### microtask 쓸 일이 있을까?

```txt
MDN에서 권장하는 예시를 보자.
※ js에서 microtaskQueue를 쓰는 메소드는 queueMicrotask()이다.
```

```js
// 1번 코드
customElement.prototype.getData = url => {
  if (this.cache[url]) {
    this.data = this.cache[url];
    this.dispatchEvent(new Event("load"));
  } else {
    fetch(url).then(result => result.arrayBuffer()).then(data => {
      this.cache[url] = data;
      this.data = data;
      this.dispatchEvent(new Event("load"));
    });
  }
};

// 2번 코드
customElement.prototype.getData = url => {
  if (this.cache[url]) {
    queueMicrotask(() => {
      this.data = this.cache[url];
      this.dispatchEvent(new Event("load"));
    });
  } else {
    fetch(url).then(result => result.arrayBuffer()).then(data => {
      this.cache[url] = data;
      this.data = data;
      this.dispatchEvent(new Event("load"));
    });
  }
};
```

```txt
1번 코드는 if문에서 작업이 task단에서 처리되고, else문에선 작업이 microtask단에서 처리된다.
if와 else에서 처리하는 단이 다르기 때문에 애로사항이 날 수 있다고 주의한다.

2번 코드는 다르다.

if문에서는 queueMicrotask를 씀으로서 작업을 microtask단에서 처리하고,
else문에서도 promise를 통해 작업을 microtask단에서 처리한다.

이를 통해 실행 순서를 일정하게 유지할 수 있도록 보장해준다고 한다.

일반 task와 microtask가 아래와 같이 동작하는 것을 확인하자.
```

<img src="https://res.cloudinary.com/practicaldev/image/fetch/s--05Fi8vBq--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/42eatw03fcha0e1qcrf0.gif">

```js
function a() {
	queueMicrotask(() => {
		setTimeout(b, 0);
		console.log("a");
	});
}

function b() {
	console.log("b");
}

function b2() {
	console.log("b2");
}

function c() {
	console.log("c");
	setTimeout(b2, 0);
	a();
}

c();

// 이 코드는 어떻게 결과가 나올까?
// 정답은 맨 아래에.
```

```txt
MDN이 소개하는 재밌는 코드를 하나 더 소개한다.
(원문을 조금 변경했다.)
```

```js
const messageQueue = [];

let sendMessage = (message) => {
	messageQueue.push(message);

	if (messageQueue.length === 1) {
		queueMicrotask(() => {
			const json = JSON.stringify(messageQueue);
			messageQueue.length = 0;
			// 예제용 microtask 코드
			queueMicrotask(() => console.log(json));
		});
	}
};

for (let i = 0; i < 4; i++) {
	sendMessage("testMessage");
}

console.log("foo");

// 위와 같은 for문처럼 간단한 요청 몇 개가 아니라 수많은 요청이 들어왔다고 생각해보자.
```

```txt
※ sendMessage는 Call Stack에 위치한다.
※ messageQueue는 microTask Queue에 위치한다.
※ microTask Queue는 Call Stack이 완전히 비워져야 실행된다.

위 3가지 사항을 유념하고 다시 살펴보자.

1. 맨 처음에 messageQueue 배열에 "testMessage"가 한 칸 채워질 것이다.

2. if문에 따라서 queueMicrotask 내부의 함수를 microTask Queue에 등록한다.
※ 주의 : 아직 실행하지 않는다! 뭘 할지 함수 코드만 등록한 것이다! Call Stack에서 처리해야 할 것들이 남아있다.

3. Call Stack에 있는 script(for문, console.log("foo"))가 전부 종료되면
microTask Queue 내부의 함수는 그때서야 Call Stack으로 이동한 뒤 실행된다.

※ 주목할 점은 이 일련의 과정을 microTask가 딱 한 번만 실행해서 처리했다는 점이다.
Call Stack이 다 비워져야만 microTask가 실행된다는 알고리즘을 이용해서 microTask가 여러 번 호출되는 상황을 방지한 것.

Q) 만약 위 코드에서 첫 번째 queueMicrotask()를 제거하면? 

const json, messageQueue를 비우는 작업이 for문 하나하나마다 다 진행될 것이다.
그러면 microTask 호출횟수도 for문의 횟수만큼 쌓인다.
따라서 반복되는 호출로 인해 Timeout, 통신 지연 등의 부하가 생길 것이다.
```

![image](https://user-images.githubusercontent.com/39308313/149341666-525bc7ed-b6d2-4526-a913-c856932019c4.png)

	queueMicrotask()로 감싸서 작업했을 때(한 번만 호출하고 처리한다.)

![image](https://user-images.githubusercontent.com/39308313/149341359-b1184674-ff15-410c-a350-3554e534e724.png)

	queueMicrotask()로 감싸지 않고 바로 처리할 때(매번 호출하면서 처리한다.)

```js
const messageQueue = [];

let sendMessage = message => {
  messageQueue.push(message);

  if (messageQueue.length === 1) {
    queueMicrotask(() => {
      const json = JSON.stringify(messageQueue);
      messageQueue.length = 0;
      fetch("url-of-receiver", json);
    });
  }
};
```

```txt

```



![image](https://user-images.githubusercontent.com/39308313/149267336-1fa193a3-b1b1-45da-b539-81c7b0997bcf.png)


[MDN 마이크로태스크](https://developer.mozilla.org/ko/docs/Web/API/HTML_DOM_API/Microtask_guide)  
[태스크와 마이크로태스크에 관하여](https://wikidocs.net/158522)
