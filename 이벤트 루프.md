### 이벤트 루프
    
```txt
js가 단일 스레드라는 건 웬만한 사람들은 다 아는 사실이다.
메인 스레드에서 모든 코드를 동기 처리해도 아무 불만 안 생기면 다행이지만...
```
![다운로드](https://user-images.githubusercontent.com/39308313/148635367-0b8f913d-422e-4126-a37f-73fa48413efb.jpg)

```txt
그래서 Event loop란 개념을 알아두면 좋다.

크게 다음과 같은 요소를 생각할 수 있다.
```

1. Call Stack
2. MacroTask Queue
3. MicroTask Queue
4. Animation Frame

- Call Stack

```txt
여러 메소드, 함수 등을 넣는 스택.
이벤트 루프는 콜스택에 있는 애들이 다 비워질 때까지 계속 돌린다.
코드 실행 우선 순위는 Call stack -> microtask -> task라고 생각하면 편하다.
```

- MacroTask Queue

```txt
이후로는 MacroTask 대신 Task Queue로 생략해서 부르겠다.
taskqueue에 들어가는 대표적 예시는 setTimeout이다.

 - 실행 원리

1. Call Stack에 setTimeout이 올라간다.

2. 내부 함수는 WepAPIs로 이동, setTimeout에 설정된 시간만큼 countdown을 한다.

3. Call Stack은 담겨있는 작업들을 처리.

4. 카운트 다운이 끝나면 setTimeout의 내부함수는 web API => task queue로 이동. 
※주의 : 카운트다운이 끝나면 task queue로 이동하는 거다. 카운트다운이 끝나고 바로 실행하는 게 아니다.

5. Call Stack이 비워지면 task queue에 있는 함수들은 call stack으로 이동한 뒤 실행된다.

※ 겉보기에 큐처럼 행동하지만 실제 구조는 set이다.

※ Task Queue는 콜백 함수뿐 아니라 이벤트, 스크립트, HTML parse 등을 담는다.

※ setTimeout은 V8 소스 코드에 없다. 
브라우저에서 제공하는, js가 실행되는 런타임 환경에 있는 API이다.
```

<img src ="https://res.cloudinary.com/practicaldev/image/fetch/s--6NSYq-nO--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/yqoemb6f32lvovge8yrp.gif">

<img src="https://res.cloudinary.com/practicaldev/image/fetch/s--us8FF30N--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/6wxjxduh62fqt531e2rc.gif">


```txt
Q) 만약 아래처럼 코드를 짜면 출력 순서는 어떻게 될까?
```

```javascript
function a() {
  console.log('a');
}

function b() {
  console.log('b');
}

function c() {
    setTimeout(b, 0);
    a();
    console.log('c');
}

c();
```

```txt
아래는 어떻게 될까?
```

```javascript
function c() {
    setTimeout(b, 100);
    setTimeout(a, 0);
    console.log('c');
}
```

## 헷갈린다면 다시 살펴보자

![image](https://user-images.githubusercontent.com/39308313/144361895-85407884-7049-4d0e-bb6d-c122ea7140db.png)

```txt
forEach를 그냥 돌리면 각 index마다 console.log()를 동기적으로 돌린다. 
하지만 setTimeout을 써서 task에 넣어서 처리하면?
```

![image](https://user-images.githubusercontent.com/39308313/144361671-f3a8b498-dc4b-4772-bb56-e68ed2823b09.png)

### 왜 이렇게?

![image](https://user-images.githubusercontent.com/39308313/144360746-b051a3da-561b-45f2-9efc-78e823293359.png)

```txt
참고) onClick()이벤트 등등도 taskQueue에 들어가서 처리된다.
```

```txt
몇 개 console.log 찍는 건 금방이니까 괜찮다. 
그런데 시간이 오래 걸리는 작업이면?
콜스택 비우는 데에도 시간이 오래 걸린다.

브라우저는 매 16.6ms마다 화면을 repaint한다(초당 60프레임).

그런데 Call Stack에 코드가 남아있으면 redering을 못한다

처리중인 이벤트가 있으면 텍스트 선택, 클릭 등 다른 모든 이벤트가 다 막힌다.
스택에 있는 애들 처리하느라 바쁘니까.

만약 마우스 스크롤 등등의 모든 이벤트를 동기적으로 처리하다간 사용자가 속터질 것이다.

따라서 필요에 따라 비동기로 작동시키는 것이다.
```

- Animation Frame

```txt
렌더링은 다음과 같은 단계를 거친다.
rAF => styling => Layout => Painting

※ 렌더링 때마다 처리하고 싶은 이벤트가 있다면 setTimeout 말고 rAF(requestAnimationFrame)을 써보자.
```

```js
const Animation = () => {
	let x = 1;
	const box = document.querySelector("div");
	function moveBox() {
		box.style.transform = `translateX(${x}px)`;
		x += 5;
	}
	function callback() {
		moveBox();
		// requestAnimationFrame(callback);
		// setTimeout(callback, 1000 / 60);
	}
	callback();
	return (
		<>
			<div id="box" className={styles.box}></div>
		</>
	);
};
```

```txt
위와 같은 코드를 짰을 때, setTimeout과 requestAnimationFrame은 각각 초당 60프레임 간격으로 box를 오른쪽으로 움직인다.
그러면 둘이 뭐가 다를까?
```

![image](https://user-images.githubusercontent.com/39308313/148680983-45fd093a-f4f4-45ac-bd5f-ba9e774b9c06.png)

	우리는 setTimeout이 위와 같이 작동하기를 바란다.
        
![image](https://user-images.githubusercontent.com/39308313/148681027-be73ff40-0f15-45be-affa-033bfed1465c.png)

	하지만 정확하게 작동하지 않는다. 루틴이 깨질 수도 있고, 작업 처리 시간 때문에 렌더링이 늦춰질 수 있다.
        
![image](https://user-images.githubusercontent.com/39308313/148681046-0475d612-a1a9-4d71-8d59-0918339c6544.png)

	requestAnimationFrame을 사용하면 위와 같이 렌더링마다 작동하기 때문에 문제가 없다.
        
```txt
위의 코드를 각각 실행해보면 setTimeout은 실행 도중에 박스의 움직임이 뚝뚝 끊기는 반면,
requestAnimationFrame은 부드럽게 잘 실행된다.
```

- MicroTask Queue

```txt
JavaScript 'promises' and the 'Mutation Observer API' both use the 'microtask queue' to run their callbacks
-MDN에서 발췌-

microtask의 대표적 예시는 promise이다.

wikidocs에서는 아래와 같은 설명을 한다.

1. Task queue에서 가장 오래된 작업을 처리
2. Microtask Checkpoint 실행
3. 필요하다면 렌더링 실행
	resize, scroll 등을 실행
	animation frame callbacks 실행 (requestAnimationFrame을 사용한 콜백 함수)
	update intersection observation steps 실행
	화면 업데이트
	
Microtask Checkpoint 실행은 Microtask Queue에 담긴 microtask를 실행하는 것으로, 규칙은 아래와 같다.

1. “perfoming a microtask checkpoint” 변수가 false이면 계속한다.
2. “perfoming a microtask checkpoint”를 참으로 한다.
3. 이벤트 루프의 마이크로태스크 큐가 빌 때까지:
	마이크로태스크 큐의 가장 오래된 마이크로태스크를 실행한다.
	이 때, 실행 중인 마이크로태스크가 콜백을 실행하는 경우, Microtask Checkpoint가 실행되는데, 
	이 때에는 “perfoming a microtask checkpoint”가 이미 참이기 때문에, 이 반복문이 2중으로 실행되는 것을 방지한다.
	
아래와 같이 간단히 생각해보자.
```

![image](https://user-images.githubusercontent.com/39308313/148636153-0398ed21-e8c2-4e23-bc9f-d99224f9787d.png)

- Task Queue는 Call Stack에 하나 넣고, Call Stack이 비워지길 기다리고, 중간에 microtask나 렌더링

- Animation Callback Queue는 Call Stack에 순서대로 넣지만, 새로 추가되는 작업들은 다음 프레임에서 처리한다.

- MicroTask Queue는 새로 들어오는 작업들도 포함해서 Queue가 다 비워질 때까지 계속 Call Stack에 넣는다.

![image](https://user-images.githubusercontent.com/39308313/148636323-d544b6fa-6490-4143-8d9c-381b534539c9.png)

```txt
task queue에 클릭 메소드 2개가 들어갈 것이고, 첫 번째 클릭 이벤트 처리로 Listener 1 => MicroTask 1이 출력될 것이다.
그 다음으로 task queue에 남아있던 2번째 이벤트가 stack에 들어와서 처리될 것이다.
따라서 Listener 1 => MicroTask 1 => Listener 2 => MicroTask 2순으로 출력된다.
```

![image](https://user-images.githubusercontent.com/39308313/148649468-b58b5a7b-4420-4f78-acdf-dc9a80ffd54f.png)

```txt
이건 콘솔 결과가 어떻게 뜰까?

js script가 Call Stack에 깔려있기 때문에 웹에서 마우스 클릭했을 때와 완전히 다른 결과가 나온다.
첫 번째 클릭 이벤트를 처리해도 script가 Call Stack에 남아있기 때문에 두 번째 클릭 이벤트도 실행한다.
MicroTask Queue도 Call Stack이 비워질 때까진 기다려야 하기 때문에 MicroTask 1, MicroTask 2가 쌓여있는 상태다.
즉, 결과는 Listener 1 => Listener 2 => MicroTask 1 => MicroTask 2다.
```

![6](https://user-images.githubusercontent.com/39308313/149320626-24faa018-4fc7-4260-9cf3-4223ea27c187.jpg)

### microTask Queue 어디에 쓰지?

```txt
MDN에 들어가면 microtask queue를 쓸 일은 많지 않으며, 사용할 시에 주의가 필요하다고 한다.
권장하는 예시를 보자.
```

```js
// 1번 코드
customElement.prototype.getData = url => {
  if (this.cache[url]) {
    this.data = this.cache[url];
    this.dispatchEvent(new Event("load"));
  } else {
    fetch(url).then(result => result.arrayBuffer()).then(data => {
      this.cache[url] = data;
      this.data = data;
      this.dispatchEvent(new Event("load"));
    });
  }
};

// 2번 코드
customElement.prototype.getData = url => {
  if (this.cache[url]) {
    queueMicrotask(() => {
      this.data = this.cache[url];
      this.dispatchEvent(new Event("load"));
    });
  } else {
    fetch(url).then(result => result.arrayBuffer()).then(data => {
      this.cache[url] = data;
      this.data = data;
      this.dispatchEvent(new Event("load"));
    });
  }
};
```

```txt
1번 코드는 if문에서 작업이 task단에서 처리되고, else문에선 작업이 microtask단에서 처리된다.
if와 else에서 처리하는 단이 다르기 때문에 애로사항이 날 수 있다고 주의한다.

2번 코드는 다르다.

if문에서는 queueMicrotask를 씀으로서 작업을 microtask단에서 처리하고,
else문에서도 promise를 통해 작업을 microtask단에서 처리한다.

이를 통해 실행 순서를 일정하게 유지할 수 있도록 보장해준다고 한다.

일반 task와 microtask가 아래와 같이 동작하는 것을 확인하자.
```

<img src="https://res.cloudinary.com/practicaldev/image/fetch/s--05Fi8vBq--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/42eatw03fcha0e1qcrf0.gif">

```js
function a() {
	queueMicrotask(() => {
		setTimeout(b, 0);
		console.log("a");
	});
}

function b() {
	console.log("b");
}

function b2() {
	console.log("b2");
}

function c() {
	console.log("c");
	setTimeout(b2, 0);
	a();
}

c();

// 이 코드는 어떻게 결과가 나올까?
```

![image](https://user-images.githubusercontent.com/39308313/149267336-1fa193a3-b1b1-45da-b539-81c7b0997bcf.png)


[MDN 마이크로태스크](https://developer.mozilla.org/ko/docs/Web/API/HTML_DOM_API/Microtask_guide)  
[태스크와 마이크로태스크에 관하여](https://wikidocs.net/158522)
