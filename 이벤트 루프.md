### 이벤트 루프

    js가 비동기를 처리하는 일련의 loop
    
```txt
js는 단일 스레드로 돌아간다.
메인 스레드에서 모든 코드를 동기 처리해도 아무런 문제가 없다면 다행이지만...
```
![다운로드](https://user-images.githubusercontent.com/39308313/148635367-0b8f913d-422e-4126-a37f-73fa48413efb.jpg)

```txt
그래서 Event loop는 다음과 같은 요소들로 나눠볼 수 있다.
```

1. Call Stack
2. Task Queue
3. MicroTask Queue


- Call Stack

```txt
함수를 넣는 스택.
이벤트 루프는 콜스택이 빌 때까지 스택에 있는 함수들을 실행한다.
```

- Task Queue

```txt
setTimeout을 예시로 들겠다.

 - 실행 원리

1. Call Stack에 setTimeout이 올라간다.
2. 내부 함수는 WepAPIs로 이동, countdown을 한다.
3. Call Stack은 담겨있는 작업들을 처리.
4. 카운트 다운이 끝나면 setTimeout의 내부함수는 web API => task queue로 이동.
5. 내부함수는 Call Stack이 비워지면 그제야 Call Stack으로 넘겨진 다음 실행된다.

※ 구글엔 message queue vs task queue라는 주제가 있다.
둘이 다른 모양인데, 검색해서 알아보면 좋을 듯하다.

※ 겉보기에 큐처럼 행동하지만 실제 구조는 set이다.

※ Task Queue는 콜백 함수뿐 아니라 이벤트, 스크립트, HTML parse 등을 담는다.

※ setTimeout은 V8 소스 코드에 없다. 
브라우저에서 제공하는, js가 실행되는 런타임 환경에 있는 API이다.
```

![image](https://user-images.githubusercontent.com/39308313/144356805-87e7041c-7ca9-41ed-9cf5-5af3c9bf1c52.png)

![image](https://user-images.githubusercontent.com/39308313/144360100-d6a69889-18f0-4e8e-a8c7-e835ed323bbb.png)

```javascript
function a() {
  console.log('a');
}

function b() {
  console.log('b');
}

function c() {
    setTimeout(b, 0);
    a();
    console.log('c');
}

c();
```

![image](https://user-images.githubusercontent.com/39308313/144221789-50c7f629-7fa5-4ec8-90b1-6ab53ed34199.png)

```txt
Call Stack: [c, a]
Message Queue : [ b ]
따라서 a -> c를 실행해서 콜스택을 비운 뒤에 메시지 큐에 있는 b가 콜스택으로 이동한 뒤 출력된다.

Q) 만약 아래처럼 코드를 짜면 어떻게 될까?
```

```javascript
function c() {
    setTimeout(b, 100);
    setTimeout(a, 0);
    console.log('c');
}
```

```txt
Call Stack : [c]
Message Queue : [a , b]
가 된다.
b는 100ms 뒤에 Call Stack으로 가는 게 아니라, 100ms 뒤에 Message Queue로 간다.
따라서 a가 먼저 메시지 큐에 들어갔기 때문에 a -> b 순으로 콜스택에 들어간다.
```

## 그래서 이거 왜 쓰는데?

![image](https://user-images.githubusercontent.com/39308313/144360746-b051a3da-561b-45f2-9efc-78e823293359.png)

```txt
setTimeout은 예시이다. setTimeout만 저렇게 돌아가는 게 아니다.
HTML에서 onClick()이벤트 처리 등도 이런 식으로 적용이 된다.
```

![image](https://user-images.githubusercontent.com/39308313/144361895-85407884-7049-4d0e-bb6d-c122ea7140db.png)

```txt
위 코드에서 그냥 forEach를 돌리면 각 index마다 console.log()를 동기적으로 돌린다. 

async로 돌릴 경우는 아래와 같이 된다.
```

![image](https://user-images.githubusercontent.com/39308313/144361671-f3a8b498-dc4b-4772-bb56-e68ed2823b09.png)

```txt
각 index마다 바로 콜스택을 비우는 게 아니라 큐에 집어넣는다.
```

### 왜 이렇게?

    콜스택이 비워지기 전엔 다른 작업을 못하니까.

```txt
몇 개 console.log 찍는 건 금방이니까 괜찮다. 
그런데 시간이 오래 걸리는 작업이면?
콜스택 비우는 데에도 시간이 오래 걸린다.

브라우저는 매 16.6ms마다 화면을 repaint한다(초당 60프레임).

그런데 Call Stack에 코드가 남아있으면 redering을 못한다

그동안에 텍스트 선택, 클릭 등 이벤트 작동도 다 막힌다.
왜? 스택에 있는 애들 처리하느라 바쁘니까.

이를 테면 마우스 스크롤 이벤트가 동기적으로 작동하면?
엄청 많은 함수들이 스택에 쌓일 것이고,
스크롤을 내리는 동안 다른 짓을 못한다.

따라서 필요에 따라 비동기로 작동시키는 것이다.

※타이머, 네트워크, 렌더링 주기마다 처리할 이벤트가 있다면 setTimeout 대신 rAF(requestAnimationFrame)을 써보자.
렌더링은 다음과 같은 단계를 거친다.
rAF => styling => Layout => Painting

```

### Task Queue vs MicroTask Queue

![image](https://user-images.githubusercontent.com/39308313/148636153-0398ed21-e8c2-4e23-bc9f-d99224f9787d.png)

```txt
Task Queue는 Call Stack에 하나 넣고, Call Stack이 비워지길 기다리고, 다시 Call Stack에 하나 넣고, 기다린다.

Animation Callback Queue는 Call Stack에 순서대로 넣지만, 새로 추가되는 작업들은 다음 프레임에서 처리한다.

MicroTask Queue는 새로 들어오는 작업들도 포함해서 Queue가 다 비워질 때까지 계속 Call Stack에 넣는다.

```


![image](https://user-images.githubusercontent.com/39308313/148636323-d544b6fa-6490-4143-8d9c-381b534539c9.png)

```txt
콘솔 결과가 어떻게 뜰까?

task queue에 클릭 메소드 2개가 들어갈 것이고, 첫 번째 클릭 이벤트 처리로 Listener 1 => MicroTask 1이 출력될 것이다.
그 다음으로 task queue에 남아있던 2번째 이벤트가 stack에 들어와서 처리될 것이다.
따라서 Listener 1 => MicroTask 1 => Listener 2 => MicroTask 2순으로 출력된다.
```

![image](https://user-images.githubusercontent.com/39308313/148649468-b58b5a7b-4420-4f78-acdf-dc9a80ffd54f.png)

```txt
이건 콘솔 결과가 어떻게 뜰까?

js script가 Call Stack에 깔려있기 때문에 웹에서 마우스 클릭했을 때와 완전히 다른 결과가 나온다.
첫 번째 클릭 이벤트를 처리해도 script가 Call Stack에 남아있기 때문에 두 번째 클릭 이벤트도 실행한다.
MicroTask Queue도 Call Stack이 비워질 때까진 기다려야 하기 때문에 MicroTask 1, MicroTask 2가 쌓여있는 상태다.
즉, 결과는 Listener 1 => Listener 2 => MicroTask 1 => MicroTask 2다.
```
